##### ДЗ. Тема 8. Купи

### Завдання 1

'''
Уявіть, що вам на технічному інтерв'ю дають наступну задачу, яку треба розв'язати за допомогою купи.

Є декілька мережевих кабелів різної довжини, їх потрібно об'єднати по два за раз в один кабель, використовуючи з'єднувачі, у порядку, який призведе до найменших витрат. 
Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин, а загальні витрати дорівнюють сумі з'єднання всіх кабелів.

Завдання полягає в тому, щоб знайти порядок об'єднання, який мінімізує загальні витрати.

Критерії прийняття:
Код виконується і повертає мінімальну з можливих сум загальних витрат.
'''

import heapq

cabels = [4, 2, 5, 1, 3]

def merge_cabels(cabels):
   heapq.heapify(cabels)                 # Помістити всі довжини кабелів у мін-купу, що була можливість надалі діставати по 2 найкоротші кабелі.     
   total_cost = 0                          # Ініціалізуємо суму загальних витрат
   print(f'Крок 0: Початкові загальні витрати = {total_cost}, Початкова купа: {cabels}')
   step = 1                                # Step - для покрокової демонстрації виконання алгоритму

   while len(cabels) > 1:                  # Поки в купі більше ніж 1 кабель (коли залишився 1 кабель — це фінальний кабель, і всі витрати вже враховані):
       cabel_1 = heapq.heappop(cabels)      # Взяти 1-й найменший кабель 
       cabel_2 = heapq.heappop(cabels)      # Взяти 2-й найменший кабель
       cost_1_2 = cabel_1 + cabel_2         # Обчислити їхню суму (вартість об'єднання)
       total_cost += cost_1_2                   # Додати цю суму до загальних витрат.
       heapq.heappush(cabels, cost_1_2)         # Помістити новий об'єднаний кабель назад у купу, бо цей новий кабель тепер теж потрібно враховувати

       print(f'Крок {step}: з\'єднуємо два найменші кабелі {cabel_1} + {cabel_2} = {cost_1_2}, загальні витрати \'Крок {step}\' = {total_cost} (загальні витрати Крок {step-1} + витрати Крок {step}), нова купа: {cabels}' )
       step += 1
   print(f'Алгоритм завершено, оскільки залишився тільки 1 кабель довжиною {cabels}, якого немає з чим поєднувати більше')
   print(f'Загальні витрати: {total_cost}')
   return total_cost

merge_cabels(cabels)

# Коментар
'''
Чому в результаті виходить 33:
Кроки:

Початкова купа: [1, 2, 5, 4, 3]
(не відсортовано, але heap-порядок правильний)

1. З'єднуємо 1 + 2 = 3
- нова купа: [3, 3, 5, 4]
- total_cost = 3

2. З'єднуємо 3 + 3 = 6
- нова купа: [4, 5, 6]
- total_cost = 3 + 6 = 9

3. З'єднуємо 4 + 5 = 9
- нова купа: [6, 9]
- total_cost = 9 + 9 = 18

4. З'єднуємо 6 + 9 = 15
- нова купа: [15]
- total_cost = 18 + 15 = 33
'''




#### Завдання 2 (Необов'язкове завдання)
'''
Дано k відсортованих списків цілих чисел. Ваше завдання — об'єднати їх у один відсортований список. Тепер при виконанні завдання ви повинні використати мінімальну купу для ефективного злиття кількох відсортованих списків в один відсортований список. Реалізуйте функцію merge_k_lists, яка приймає на вхід список відсортованих списків та повертає відсортований список.

Приклад очікуваного результату:

lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
print("Відсортований список:", merged_list)

Виведення:

Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]
'''

import heapq

def merge_k_lists(lists):
   
   def heap_sort(iterable):
      # Створюємо мінімальну купу з усіх елементів ітерабельного об'єкта.
      h = []
      for value in iterable:
         heapq.heappush(h, value)
      
      # Витягуємо елементи впорядковано, формуючи відсортований масив.
      return [heapq.heappop(h) for _ in range(len(h))]

   listic = []
   for lst in lists:            # для кожного списку зі списку списків - як альтернативний варіант коду [listic.extend(lst) for lst in lists] замість 2 викликів for
        for el in lst:            # для кожного елементу кожного списку
            listic.append(el)   # вставляємо всі елементи в єдиний об'єднаний список
   
   return heap_sort(listic)     # сортуємо об'єднаний список перетворючи його в міні-купу


lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
print("Відсортований список:", merged_list)

'''
Виведення:

Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]

'''